%% Práctica 02: Señales en tiempo continuo
%
% *Intituto Politécnico Nacional*
%
% *Unidad Profesional Interdisciplinaria en Ingeniería y Tecnologías Avanzadas*
%
% *Análisis de Señales y Sistemas*
%
% *Grupo: 2MV1*
%
% *Alumnos:*
% 
% * Ordorica Muñoz Leonardo Antonio
%
% * Carmona Bellido Marco Tulio
%% Introducción
% MATLAB es un lenguaje de programación interpretado e interactivo, esto significa que a diferencia de C o
% Fortran no se generan ejecutables sino que un programa llamado interprete recibe órdenes y las ejecuta.
% Estas órdenes se comunican al intérprete mediante un lenguaje de programación que recibe el mismo
% nombre que el programa, Matlab. Entonces utilizar Matlab es equivalente a programar en Matlab.
% Matlab cuenta con una biblioteca de cálculo numérico y de ingeniería tan extensa como útil y el
% intérprete es extensible mediante distintos lenguajes compilados como C y Fortran.
% Matlab tiene la gran virtud convertir en triviales tareas fáciles como las operaciones elementales.
% Matlab, abreviatura de MATrix LABoratory, "laboratorio de matrices", como su nombre lo indica, trabaja
% con matrices siempre, por lo que se deben hacer ciertas consideraciones a la hora de realizar operaciones
% entre estas, tales como la multiplicación de matrices, entre otros.
% Se encuentra disponible como aplicación descargable e instalable en sistemas como Windows, OSX (Mac) y Linux.
% <https://la.mathworks.com/products.html?s_tid=gn_ps Página oficial de Productos MATLAB.>
%
% Aunque se tienen alternativas descargables, tambien existen opciones disponibles en línea (no descargables),
% tales como <https://octave-online.net/ Octave Online>, la cual es una plataforma casi idéntica a la sintaxis
% Matlab, con excepción de que en Octave Online se permiten algunos comandos e instrucciones que en Matlab no
% existen, un ejemplo son las instrucciones que se le pueden dar al declarar una variable, en Octave Online se le
% puede indicar que cierta variable es un entero positivo, etc. Una de las ventajas muy importantes de Octave es que
% es software libre (gratuito), que por otro lado, Matlab es un producto comercial. También existen otras alternativas
% como <https://jupyter.org/ Jupyter>, el cual trabaja con el lenguaje Python pero que igual es muy amigable.
% Matlab es un producto de MathWorks. Fue diseñado a finales de los 70 por Cleve Moler como una herramienta
% para evitar a sus estudiantes tener que aprender Fortran. Apareció como producto comercial en el año 1984
% y desde entonces ha ido gandando adeptos, sobretodo en el campo del control lineal y no lineal y en la
% ingeniería en general.
%
% *Cursos para Matlab y Octave:*
%
% * <https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-094-introduction-to-matlab-january-iap-2010/index.htm Matlab>
%
% * <https://www.edx.org/es/course/matlab-octave-beginners-epflx-matlabeoctavebeginnersx Octave y Matlab para Principiantes>

%% Objetivos
% * Manipulación básica de MATLAB
% * Gráficas de señales reales y complejas continuas
% * Transformación de señales continuas (escalamientos y traslaciones)
% * Calculo de energía y potencia de señales continuas

%% Desarrollo
% 
%% Problema 1
%
%% Problema 2
%
%% Problema 3
%
%% Problema 4
% *M1.1 Funciones Inline (aqui son anónimas)*
%
% Se define la función como una fución anónima con la siguiente sintaxis
% "nombredelafuncion=@(argumentos) expresionmatematica"
%
%%
f=@(t) exp(-t).*cos(2*pi*t);
%%
% Se le puede pasar como argumento una variable
%%
t=0;
f(t)
%%
% Pero también se puede pasar el valor directamente y se obtiene el
% mismo resultado
%%
f(0)
%%
% Las entradas vectoriales permiten la evaluación de múltiples valores
% simultáneamente. Considere la tarea de trazar f(t) sobre el intervalo
% (-2 &le; t &le; 2).
% El comportamiento general de la función es claro: f(t) debe oscilar
% cuatro veces con comportamiento decreciente. Dado que los bosquejos
% a mano precisos son engorroso, las gráficas generadas por MATLAB son una
% alternativa atractiva. Como se ilustra en el siguiente ejemplo, se debe
% tener cuidado para garantizar resultados fiables.
% Supongamos que el vector t se elige para incluir solo los números enteros
% contenidos en (-2 &le; t &le; 2), a saber, [-2, -1, 0, 1, 2].
%%
t=(-2:2);
%%
% Esta entrada vectorial es evaluada para entregar en la salida una salida
% vectorial
%%
f(t)
%%
% El comando plot grafica el resultado, el cual se muestra en la Figura
% M1.1.
%%
figure
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
title('Figura M1.1: f(t)=e^{-t}cos(2\pit) para t=(-2:2)')
%%
% Las líneas de cuadrícula, agregadas mediante el comando grid, ayudan a la identificación
% de la función. Desafortunadamente, la gráfica no ilustra el comportamiento oscilatorio esperado.
% Se requieren más puntos para representar adecuadamente f(t).
% La pregunta, entonces, es ¿cuántos puntos son suficientes? Si se eligen pocos puntos,
% la información se pierde. Si se eligen demasiados puntos, la memoria y el tiempo se pierden.
% Se necesita un equilibrio. Para funciones oscilatorias, el trazado de 20 a 200 puntos por oscilación
% es normalmente adecuado. Para el presente caso, se elige t para dar 100 puntos por oscilación.
%%
t=(-2:0.01:2);
%%
% Nuevamente, la función es evaluada y graficada.
% El resultado, mostrado en la Figura M1.2 es una representación precisa de f(t).
figure
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
title('Figura M1.2: f(t)=e^{-t}cos(2\pit) para t=(-2:0.01:2)')
%%
% *M1.2: Operadores relacionales y la función escalón unitario*
%%
% La función escalon unitario u(t) surge naturalmente en muchas situaciones prácticas. Por ejemplo,
% un paso de unidad puede modelar el acto de encender un sistema. Con la ayuda de operadores relacionales,
% los objetos en línea pueden representar la función de paso de unidad.
%
% En MATLAB, un operador relacional compara dos elementos. Si la comparación es verdadera, se devuelve un
% verdadero lógico (1). Si la comparación es falsa, se devuelve un falso lógico (0). Algunas veces llamadas
% funciones de indicador, los operadores relacionales indican si una condición es verdadera. Hay seis operadores
% relacionales disponibles: <,>, <=, >=, == y ~=.
%
% La función escalón unitario se define facilmente utilizando el operador relacional >=.
%%
u=@(t) t>=0;
%%
% Cualquier función con una discontinuidad de salto, como el escalón unitario, es difícil de trazar. Considere
% trazar u(t) usando t = (−2:2).
%%
t=(-2:2);
figure
plot(t,u(t));
xlabel('t'); ylabel('u(t)');
title('Figura M1.3: u(t) para t = (-2:2)')
%%
% Dos problemas significativos son evidentes en la gráfica resultante, que se muestra en la Figura M1.3. En primer
% lugar, MATLAB escala automáticamente los ejes del trazado para delimitar estrechamente los datos. En este caso,
% esta característica normalmente deseable, oculta la mayor parte de la trama. En segundo lugar, MATLAB conecta los
% datos del trazado con las líneas, lo que dificulta el logro de una discontinuidad de salto real. La resolución
% aproximada del vector t enfatiza el efecto al mostrar una línea de pendiente errónea entre t = -1 y t = 0.
%%
% El primer problema se corrige al ampliar verticalmente el cuadro delimitador con el comando axis. El segundo
% problema se reduce, pero no se elimina, agregando puntos al vector t.
%%
t=(-2:0.01:2);
figure
plot(t,u(t));
xlabel('t'); ylabel('u(t)');
axis([-2 2 -0.1 1.1]);
title('Figura M1.4: u(t) para t=(-2:0.01:2) con modificación de ejes');
%%
% El argumento vectorial de cuatro elementos del eje especifica el mínimo del eje x, el máximo del eje x, el mínimo
% del eje y, y el máximo del eje y, respectivamente. Los resultados mejorados se muestran en la Fig. M1.4.
%
% Los operadores relacionales se pueden combinar utilizando AND lógico, OR lógico y negación lógica: &, | y ~,
% respectivamente. Por ejemplo, (t>0) y (t<1) y ~((t <= 0) | (t> = 1)) ambos prueban si 0<t<1. Para demostrar,
% considere definir y trazar el pulso unitario p(t)= u(t)- u(t-1), como se
% muestra en la Fig. M1.5.
%%
p=@(t) (t>=0 & t<1);
t=(-1:0.01:2);
figure
plot(t,p(t));
xlabel('t'); ylabel('p(t)= u(t)- u(t-1)');
axis([-1 2 -.1 1.1]);
title('Figura M1.5: p(t)= u(t)- u(t-1) sobre t=(-1:0.01:2)');
%%
% Para los operandos escalares, MATLAB también admite dos construcciones lógicas de cortocircuito. Un AND lógico
% de cortocircuito se realiza utilizando &&, y un OR lógico de cortocircuito se realiza utilizando | |. Los operadores
% lógicos de cortocircuito a menudo son más eficientes que los operadores lógicos tradicionales porque prueban la
% segunda parte de la expresión solo cuando es necesario. Es decir, cuando la expresión escalar A se encuentra falsa en
% (A && B), la expresión escalar B no se evalúa, ya que un resultado falso ya está garantizado. De manera similar, la
% expresión escalar B no se evalúa cuando la expresión escalar A se encuentra verdadera en (A | | B), ya que un resultado
% verdadero ya está garantizado.
%%
% *M1.3: Visualizando Operaciones el la Variable Independiente*
%%
% Se encuentran comúnmente dos operaciones en la variable independiente de una función: desplazamiento y escalamiento.
% Los objetos Inline (en este caso anónimos) son adecuados para investigar ambas operaciones.
% Considere $g(t)=f(t)u(t)=e^{-t} cos(2 \pi t) u(t)$
% una versión realizable de f(t). Desafortunadamente, MATLAB no puede multiplicar los objetos inline (en este caso anonimos).
% Es decir, MATLAB informa un error para g = f*u cuando f y u son objetos inline (en este caso anónimos). Más bien, g(t) necesita definirse explícitamente.
%%
g=@(t) exp(-t).*cos(2*pi*t).*(t>=0);
%%
% Una operación combinada de desplazamiento y escalamiento se representa por g(at+b), donde a y b son constantes reales arbitrarias.
% Como ejemplo, considere graficar g(2t+1) sobre (−2 &ge; t &ge; 2). Con a = 2, la función se comprime por un factor de 2, lo que da
% como resultado el doble de oscilaciones por unidad t. Añadiendo la condición b > 0, la forma de onda se desplaza hacia la izquierda.
% Dada la función inline(en este caso anónima) g, una grafica precisa es casi trivial de obtener.
%%
t=(-2:0.01:2);
figure
plot(t,g(2*t+1));
xlabel('t'); ylabel('g(2t+1)'); grid;
title('Figura M1.6: g(2t+1) sobre t=(-2:0.01:2)');
%%
% La Figura M1.6 confirma la compresión de forma de onda esperada y el desplazamiento a la izquierda. Como comprobación final, tenga en cuenta que la función
% g(·) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t+1) debe encenderse cuando 2t+1 = 0 o en t = −0.5, un hecho confirmado
% nuevamente por la Figura M1.6.
%
% A continuación, considere la posibilidad de trazar g(−t+1) sobre (−2 %ge; t &ge; 2). Desde a < 0, la forma de onda se reflejará. Al agregar la condición b > 0,
% la forma de onda final se desplaza hacia la derecha.
%%
figure
plot(t,g(-t+1));
xlabel('t'); ylabel('g(-t+1)'); grid;
title('Figura M1.7: g(-t+1) sobre t=(-2:0.01:2)');
%%
% La Figura M1.7 confirma tanto la reflexión como el cambio a la derecha.
%
% Hasta este punto, las Figuras M1.6 y M1.7 se pueden bosquejar razonablemente a mano. Considere trazar la función más complicada h(t) = g(2t+1) + g(−t+1) sobre
% (−2 &ge; t &ge; 2) (Figura. M1.8). En este caso, un boceto a mano preciso es bastante difícil. Con MATLAB, el trabajo es mucho menos complicado.
%%
figure
plot(t,g(2*t+1)+g(-t+1));
xlabel('t'); ylabel('h(t)'); grid;
title('Figura M1.8: h(t)=g(2t+1) + g(-t+1) sobre t=(-2:0.01:2)');
%% Problema 5
%
%% Problema 6
%
%% Problema 7
%
%% Referencias
% # Guillem Borrell i Nogueras. (2007). _Octave: Una alternativa real a Matlab a coste cero._ Marzo 31, 2019,
% de Universidad Politécnica de Madria Sitio web: <https://torroja.dmt.upm.es/media/files/paper_logrono.pdf https://torroja.dmt.upm.es/media/files/paper_logrono.pdf>
